# -*- coding: utf-8 -*-
"""S22025_hw0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K2XYSQhvC505M0kZKlwdyoNUG8iXcTss
"""

from google.colab import drive
drive.mount('/content/drive')

"""1. Reading and displaying image"""

from matplotlib import pyplot as plt
image=plt.imread('/content/drive/MyDrive/5.1.12.tiff') #reading contents of an image into array
print(image)
#print(image.shape)
plt.imshow(image, cmap='gray') # displaying an image
#print(image.dtype)

"""2. Printing maximum and minimum values of pixels"""

smallest = image.min()
largest = image.max()
print(smallest)
print(largest)
levels=largest-smallest
#print(levels)

"""No. of bits required per pixel"""

import math
print("No. of bits required per pixel: ",math.ceil(math.log2(levels+ 1)))

"""Resolution of image:"""

import pandas as pd
width=image.shape[0]
height=image.shape[1]
#print(image.size)
print("Resolution: "+str(width) + "x" + str(height))
#print(width/image.size)
#df = pd.DataFrame(image.flatten())
#filepath = 'pixels.xlsx'
#df.to_excel(filepath, index=False)

"""3. Size of compressed image and comparison with 8 bits per pixel size"""

import os
#tiff file compression ratio
compressed=os.path.getsize('/content/drive/MyDrive/5.1.12.tiff')
print('Size of the compressed tiff file: ',compressed)
#print(fsize)
original=height*width*8
print('Size of 8bits per pixel file: ',original)
ratio=compressed/original
print("Ratio (using tiff file): ",ratio)
print('**********************************************')
c1=os.path.getsize('/content/drive/MyDrive/5.1.12.jpg')
print('Size of the compressed jpg file: ',c1)
img= plt.imread('/content/drive/MyDrive/5.1.12.jpg')
height,width=img.shape[:2]
ucompressed=height*width*8
print('Size of 8bits per pixel file: ',ucompressed)
r=c1/ucompressed
print("Ratio (using jpg file): ",r)

"""4. Displaying bitplane of image."""

import matplotlib.pyplot as plt
import math
import numpy as np
# Read the image in greyscale
img = plt.imread('/content/drive/MyDrive/5.1.12.tiff', 0)

def disp_bp(img,bit):
#Iterate over each pixel and change pixel value to binary using np.binary_repr() and store it in a list.
    lst = []
    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
            lst.append(np.binary_repr(img[i][j] ,width=8)) # width = no. of bits

# We have a list of strings where each string represents binary pixel value. To extract bit planes we need to iterate over the strings and store the characters corresponding to bit planes into lists.
# Multiply with 2^(n-1) and reshape to reconstruct the bit image.
    display_bit_img = (np.array([int(i[8-bit]) for i in lst],dtype = np.uint8) * 2**(7-bit)).reshape(img.shape[0],img.shape[1])
    plt.imshow(display_bit_img, cmap='gray')
    plt.title('bitplane '+str(bit))
    plt.show()

disp_bp(img,8)
disp_bp(img,7)
disp_bp(img,6)

"""5. Quantize 8 bit image to 8,4,2,1 bits"""

import numpy as np
import matplotlib.pyplot as plt

def quantize_image(image, bits):
    # Calculate the number of levels for quantization
    levels = 2**bits

    # Calculate the step size for quantization
    step = 256/levels

    # Quantize the image by rounding the pixel values to the nearest level
    quantized_image = (image//step )

    return quantized_image

# Load the image
image = plt.imread('/content/drive/MyDrive/5.1.12.tiff', 0)

# Quantize the image to 8 bits
quantized_image_8 = quantize_image(image, 8)

# Quantize the image to 4 bits
quantized_image_4 = quantize_image(image, 4)

# Quantize the image to 2 bits
quantized_image_2 = quantize_image(image, 2)

# Quantize the image to 1 bit
quantized_image_1 = quantize_image(image, 1)

# Plot the original and quantized images

plt.imshow(image, cmap='gray')
plt.title('Original Image')
plt.show()

plt.figure(figsize=(15, 10))
plt.subplot(2, 2, 1)
plt.imshow(quantized_image_8, cmap='gray')
plt.title('Quantized Image (8 bits)')

plt.subplot(2, 2, 2)
plt.imshow(quantized_image_4, cmap='gray')
plt.title('Quantized Image (4 bits)')

plt.subplot(2, 2, 3)
plt.imshow(quantized_image_2, cmap='gray')
plt.title('Quantized Image (2 bits)')

plt.subplot(2, 2, 4)
plt.imshow(quantized_image_1, cmap='gray')
plt.title('Quantized Image (1 bit) ')
plt.show()

"""### Question 2:

1. Reading RGB image and displaying each channel seperately
"""

import numpy as np
import matplotlib.pyplot as plt


def split_intochannels(image):
  # Load image
  img = plt.imread(image)

  # Split channels
  r ,g ,b = img[:, :, 0] ,img[:, :, 1] , img[:, :, 2]

  plt.figure(figsize=(15, 10))
  plt.subplot(2, 2, 1)
  plt.imshow(img)
  plt.title('Original Image')

  plt.subplot(2, 2, 2)
  plt.imshow(r , cmap='Reds')
  plt.title('Red channel')

  plt.subplot(2, 2, 3)
  plt.imshow(g, cmap='Greens')
  plt.title('Green channel')

  plt.subplot(2, 2, 4)
  plt.imshow(b, cmap='Blues')
  plt.title('Blue channel')

split_intochannels('/content/drive/MyDrive/bg1.jpg')

"""Converting RGB to grayscale"""

def rgb_to_gray(img):
    r ,g ,b = img[:, :,0] ,img[:, :,1] , img[:,:,2]
    gray= 0.299*r + 0.587*g + 0.114*b
    return gray
img=plt.imread('/content/drive/MyDrive/bg1.jpg')
plt.title('Grayscale image')
gray_img=rgb_to_gray(img)
plt.imshow(gray_img,cmap='gray')
plt.show()

"""2. Most frequently occurring color from image."""

#most frequent ocuring color
img=cv2.imread('/content/drive/MyDrive/fg.jpg')
import numpy as np
from google.colab.patches import cv2_imshow
img_temp = img.copy()
unique, counts = np.unique(img_temp.reshape(-1, 3), axis=0, return_counts=True)
img_temp[:,:,0], img_temp[:,:,1], img_temp[:,:,2] = unique[np.argmax(counts)]
#print(img_temp.shape)
cv2_imshow(img_temp)

img = cv2.imread('/content/drive/MyDrive/fg.jpg')
bg = cv2.imread('/content/drive/MyDrive/bg.jpg')

img_temp2 = img.copy()
def frequent_color():
  for i in range (0,img_temp.shape[0]):
    for j in range (0,img_temp.shape[1]):
      for k in range (0,img_temp.shape[2]):
        if (img_temp2[i][j][k]== img_temp[i][j][k]):
          img_temp2[i][j][k] = bg[i][j][k]

frequent_color()

cv2_imshow(img_temp2)

"""Question 3:

Extracting frames from mp4 video
"""

import cv2

# Read the video from specified path
cam = cv2.VideoCapture("/content/drive/MyDrive/big_buck_bunny_720p_1mb.mp4")

def extract_frames(cam):

# frame
  currentframe = 0
  count=0

  while(True):

      # reading from frame
      ret,frame = cam.read()

      if ret:
          # create frames for the complete length of video
          # save frame
          name = '/content/drive/MyDrive/Frame/frame' + str(count) + '.jpg'
          print ('Creating...' + name)

          # writing the extracted images
          cv2.imwrite(name, frame)

          # increasing counter so that it will show how many frames are created
          currentframe += 10 # i.e. at 30 fps, this advances one second
          count+=1
          cam.set(1, currentframe)
      else:
          break

extract_frames(cam)

"""2. Quantize frames , convert images to video an run video.



"""

def quantization (L,i_min,i_max,img):
  q = (i_max-i_min)/L
  t = np.zeros(L+1)
  r = np.zeros(L)
  t[0]=i_min
  t[L]=i_max
  k=0
  for i in range(1,L):
    t[i]=t[i-1]+q
    r[i]=t[i]+(q/2)
  for i in range (0,img.shape[0]):
    for j in range (0,img.shape[1]):
      f=img[i][j]
      for k in range (0,L):
        if (f>=t[k] and f<t[k+1]):
            img[i][j]=r[k]
            #print("r")
  return img

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
path = '/content/drive/MyDrive/Frame/'
frame = 0
for image in os.listdir(path):
  name = '/content/drive/MyDrive/Frame/frame' + str(frame) + '.jpg'
  img = cv2.imread(name)
  #cv2_imshow(img)
  blue = quantization(2,0,255,img[:,:,0])
  green = quantization(2,0,255,img[:,:,1])
  red = quantization(2,0,255,img[:,:,2])
  final = cv2.merge((blue,green,red))
  name_ = '/content/drive/MyDrive/Quantized/frame' + str(frame) + '.jpg'
  cv2.imwrite(name_,final)
  frame += 1

import glob

img_array = []
for filename in glob.glob('/content/drive/MyDrive/Quantized/frame*.jpg'):
    img = cv2.imread(filename)
    height, width, layers = img.shape
    size = (width,height)
    img_array.append(img)


out = cv2.VideoWriter('/content/drive/MyDrive/Quantized/big_buck_bunny_720p_1mb.mp4',cv2.VideoWriter_fourcc(*'DIVX'), 15, size)

for i in range(len(img_array)):
    out.write(img_array[i])
out.release()

import imageio
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from skimage.transform import resize
from IPython.display import HTML

def display_video(video):
    fig = plt.figure(figsize=(3,3))

    mov = []
    for i in range(len(video)):
        img = plt.imshow(video[i], animated=True)
        plt.axis('off')
        mov.append([img])

    anime = animation.ArtistAnimation(fig, mov, interval=50, repeat_delay=1000)

    plt.close()
    return anime

video = imageio.mimread('/content/drive/MyDrive/Quantized/big_buck_bunny_720p_1mb.mp4')
HTML(display_video(video).to_html5_video())

!pip install imageio-ffmpeg

