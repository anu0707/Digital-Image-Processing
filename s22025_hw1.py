# -*- coding: utf-8 -*-
"""s22025_hw1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BphYDdmOw1kcWs8frdyAEk3nMIohQA2A

## Problem 1:

### Zoom image by 1.5 times using nearest neighbor
"""

import math
import cv2
from google.colab.patches import cv2_imshow
import numpy as np

def nn_interpolation(img):
  h,w=img.shape[0],img.shape[1]
  scale=1.5
  h_new=int(h*scale)
  w_new=int(w*scale)
  zoomed_img=np.zeros((h_new,w_new,3),dtype=int)
  #print(zoomed_img)
  for i in range(h_new):
    for j in range(w_new):
      for k in range(3):
        zoomed_img[i][j][k]=img[math.floor(i/scale)][math.floor(j/scale)][k]
  return zoomed_img

"""### Zooming using Bilinear Interpolation"""

def bl_interpolation(original_img, new_h, new_w):
	old_h, old_w, c = original_img.shape
	resized = np.zeros((new_h, new_w, c)) #size of zoomed image
	w_scale_factor = (old_w ) / (new_w ) if new_h != 0 else 0
	h_scale_factor = (old_h ) / (new_h ) if new_w != 0 else 0
	for i in range(new_h):
		for j in range(new_w):
			x = i * h_scale_factor #coordinates of original image mapped to the new image
			y = j * w_scale_factor
			#coordinate values for 4 surrounding pixels.
			x_floor = math.floor(x)
			x_ceil = min( old_h - 1, math.ceil(x))
			y_floor = math.floor(y)
			y_ceil = min(old_w - 1, math.ceil(y))
      #when coordinates of pixel in resized image coincides with pixel in original img
			if (x_ceil == x_floor) and (y_ceil == y_floor):
				q = original_img[int(x), int(y), :]
      #when x coordinate is an integer
			elif (x_ceil == x_floor):
				q1 = original_img[int(x), int(y_floor), :]
				q2 = original_img[int(x), int(y_ceil), :]
				q = q1 * (y_ceil - y) + q2 * (y - y_floor)
      #when y coordinate is an integer
			elif (y_ceil == y_floor):
				q1 = original_img[int(x_floor), int(y), :]
				q2 = original_img[int(x_ceil), int(y), :]
				q = (q1 * (x_ceil - x)) + (q2	 * (x - x_floor))
			else:
				v1 = original_img[x_floor, y_floor, :]
				v2 = original_img[x_ceil, y_floor, :]
				v3 = original_img[x_floor, y_ceil, :]
				v4 = original_img[x_ceil, y_ceil, :]

				q1 = v1 * (x_ceil - x) + v2 * (x - x_floor)
				q2 = v3 * (x_ceil - x) + v4 * (x - x_floor)
				q = q1 * (y_ceil - y) + q2 * (y - y_floor)

			resized[i,j,:] = q
	return resized.astype(np.uint8)

"""### Image 1:"""

#original image
img=cv2.imread('apple.png')
#cv2_imshow(img)

"""Zoomed image :using nearest neighbor interpolation"""

from matplotlib import pyplot as plt
zoomed_img=nn_interpolation(img)
#plt.imshow(zoomed_img)
#cv2_imshow(zoomed_img)

"""Zoomed image: using bilinear interpolation"""

h,w,c=img.shape
scale=1.5
new_h=int(h*scale)
new_w=int(w*scale)
zoom_1=bl_interpolation(img,new_h,new_w)

"""Displaying original , image interpolated using nearest neighbor, bilinear interpolation ."""

text='Original Image'
print(text.center(30))
cv2_imshow(img)
txt='Nearest Neighbor interpolation \t\t\t Bilinear interpolation '
print(txt.center(90))
show = np.concatenate((zoomed_img, zoom_1), axis=1)
cv2_imshow(show)

"""### Image 2:

Original image
"""

#original image
original_img=cv2.imread('Einstein_blackboard.jpg')
#cv2_imshow(original_img)

""" Zooming using nearest neighbor interpolation"""

zoomed=nn_interpolation(original_img)
#cv2_imshow(zoomed)

"""Zooming using bilinear interpolation"""

h,w,c=original_img.shape
scale=1.5
new_h=int(h*scale)
new_w=int(w*scale)
zoom2=bl_interpolation(original_img,new_h,new_w)

"""Displaying original , image interpolated using nearest neighbor, bilinear interpolation ."""

text='Original Image'
print(text.center(30))
cv2_imshow(original_img)
txt='Nearest Neighbor interpolation \t\t\t Bilinear interpolation '
print(txt.center(90))
show = np.concatenate((zoomed, zoom2), axis=1)
cv2_imshow(show)

"""### Image 3:

Original image
"""

#original image
original_img1=cv2.imread('image.jpg')
#cv2_imshow(original_img1)

"""Zooming using nearest neighbor interpolation"""

zoomed_i=nn_interpolation(original_img1)
#cv2_imshow(zoomed_i)

"""Zooming using bilinear interpolation"""

h,w,c=original_img1.shape
scale=1.5
new_h=int(h*scale)
new_w=int(w*scale)
zoom=bl_interpolation(original_img1,new_h,new_w)

text='Original Image'
print(text.center(30))
cv2_imshow(original_img1)
txt='Nearest Neighbor interpolation \t\t\t Bilinear interpolation '
print(txt.center(90))
show = np.concatenate((zoomed_i, zoom), axis=1)
cv2_imshow(show)

"""# Observations

#### 1. From the above plots it is observed that the edges are sharply obtained by zooming using 'Bilinear interpolation' and hence it gives better quality as compared to 'Nearest Neighbor interpolation'. This is because in bilinear interpolation pixel value is computed using 4 nearest neighbors and taking their average whereas nearest neighbor considers only nearest neighbor.
#### 2. However, computational complexity of Bilinear interpolation is 'greater' as compared to Nearest neighbor interpolation as bilinear interpolation has to compute 4 nearest neighbors and then computes weighted average of these 4 pixels and uses this value to estimate the pixel value in zoomed image whereas nearest neighbor only considers nearest neighbor .

## Problem 2: Histogram

###  1.Histogram of image
"""

from matplotlib import pyplot as plt
def plot_color_histogram(img):
    r,g,b=img[:,:,0],img[:,:,1],img[:,:,2]
    # Plot the histograms
    plt.figure(figsize=(20, 5))
    plt.subplot(1, 3, 1)
    plt.hist(r.ravel(), 256, [0, 256], color='r')
    plt.title('Red Channel')
    plt.xlim([0, 256])
    plt.xlabel('Pixel intensity')
    plt.ylabel('Frequency')

    plt.subplot(1, 3, 2)
    plt.hist(g.ravel(), 256, [0, 256], color='g')
    plt.title('Green Channel')
    plt.xlim([0, 256])
    plt.xlabel('Pixel intensity')
    plt.ylabel('Frequency')

    plt.subplot(1, 3, 3)
    plt.hist(b.ravel(), 256, [0, 256], color='b')
    plt.title('Blue Channel')
    plt.xlim([0, 256])
    plt.xlabel('Pixel intensity')
    plt.ylabel('Frequency')

    # Show the plot
    plt.show()

img=plt.imread('q2.jpg')
#print(img)
plot_color_histogram(img)

plt.imshow(img)

"""Modality of histogram"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

def mod(img):
# Compute the histogram and find the peaks
  hist, bin_edges = np.histogram(img, bins=256)
  peaks, _ = find_peaks(hist)

  num_peaks = len(peaks)
  print("The number of peaks in the histogram is:", num_peaks)
r,g,b=img[:,:,0],img[:,:,1],img[:,:,2]
mod(r)
mod(g)
mod(b)

"""##  2.MSB bits kept to 0"""

def msb_to_0(img):
#change pixel value to binary
    bin_lst = []
    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
          for k in range(img.shape[2]):
            bin_lst.append(np.binary_repr(img[i][j][k],width=8)) # width = no. of bits
    #display_bit_img = (np.array([int(i[8-bit]) for i in lst],dtype = np.uint8) * 2**(bit-1)).reshape(img.shape[0],img.shape[1])
    eight=(np.array([int(i[0]) for i in bin_lst],dtype = np.uint8) * 128).reshape(img.shape[0],img.shape[1],img.shape[2])
    eight[:]=0
    seven=(np.array([int(i[1]) for i in bin_lst],dtype = np.uint8) * 64).reshape(img.shape[0],img.shape[1],img.shape[2])
    six=(np.array([int(i[2]) for i in bin_lst],dtype = np.uint8) * 32).reshape(img.shape[0],img.shape[1],img.shape[2])
    five=(np.array([int(i[3]) for i in bin_lst],dtype = np.uint8) * 16).reshape(img.shape[0],img.shape[1],img.shape[2])
    four=(np.array([int(i[4]) for i in bin_lst],dtype = np.uint8) * 8).reshape(img.shape[0],img.shape[1],img.shape[2])
    three=(np.array([int(i[5]) for i in bin_lst],dtype = np.uint8) * 4).reshape(img.shape[0],img.shape[1],img.shape[2])
    two=(np.array([int(i[6]) for i in bin_lst],dtype = np.uint8) * 2).reshape(img.shape[0],img.shape[1],img.shape[2])
    one=(np.array([int(i[7]) for i in bin_lst],dtype = np.uint8) * 1).reshape(img.shape[0],img.shape[1],img.shape[2])
    new_img=eight+seven+six+five+four+three+two+one
    #print(eight)
    #plt.imshow(new_img)
    plot_color_histogram(new_img)
    #return new_img
img=plt.imread('q2.jpg')
#print(img)
n1=msb_to_0(img)

"""## 3. LSB kept to 0"""

def lsb_to_0(img):
#Iterate over each pixel and change pixel value to binary using np.binary_repr() and store it in a list.
    bin_lst = []
    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
          for k in range(img.shape[2]):
            bin_lst.append(np.binary_repr(img[i][j][k],width=8)) # width = no. of bits

# We have a list of strings where each string represents binary pixel value. To extract bit planes we need to iterate over the strings and store the characters corresponding to bit planes into lists.
# Multiply with 2^(n-1) and reshape to reconstruct the bit image.
    #display_bit_img = (np.array([int(i[8-bit]) for i in lst],dtype = np.uint8) * 2**(bit-1)).reshape(img.shape[0],img.shape[1])
    eight=(np.array([int(i[0]) for i in bin_lst],dtype = np.uint8) * 128).reshape(img.shape[0],img.shape[1],img.shape[2])
    seven=(np.array([int(i[1]) for i in bin_lst],dtype = np.uint8) * 64).reshape(img.shape[0],img.shape[1],img.shape[2])
    six=(np.array([int(i[2]) for i in bin_lst],dtype = np.uint8) * 32).reshape(img.shape[0],img.shape[1],img.shape[2])
    five=(np.array([int(i[3]) for i in bin_lst],dtype = np.uint8) * 16).reshape(img.shape[0],img.shape[1],img.shape[2])
    four=(np.array([int(i[4]) for i in bin_lst],dtype = np.uint8) * 8).reshape(img.shape[0],img.shape[1],img.shape[2])
    three=(np.array([int(i[5]) for i in bin_lst],dtype = np.uint8) * 4).reshape(img.shape[0],img.shape[1],img.shape[2])
    two=(np.array([int(i[6]) for i in bin_lst],dtype = np.uint8) * 2).reshape(img.shape[0],img.shape[1],img.shape[2])
    one=(np.array([int(i[7]) for i in bin_lst],dtype = np.uint8) * 1).reshape(img.shape[0],img.shape[1],img.shape[2])
    one[:]=0
    new_img=eight+seven+six+five+four+three+two+one
    #print(one)
    #print(new_img)
    plot_color_histogram(new_img)
    #return new_img
img=plt.imread('q2.jpg')
#print(img)
lsb_to_0(img)

"""Observing MSB set to 0 vs LSB set to 0"""

msb_to_0(img) #histogram for MSB set to 0
lsb_to_0(img) #histogram for LSB set to 0

"""## 4. Time required to transmit 512*512 grayscale image"""

def time_taken(i_dim,baud_r):
  n_bits_to_transmit=i_dim*8
  time=n_bits_to_transmit/baud_r
  return time
t1=time_taken(512*512,56*1000)
print("Time taken to transmit over a 56K baud link: "+str(t1)+' sec')
t2=time_taken(512*512,3000*1000)
print("Time taken to transmit over a 3000K baud link: "+str(t2)+' sec')

"""# Problem 3: Point Operations

"""

#finding negative of an image
from matplotlib import pyplot as plt
def f_invert(img):
  a_max=2**8-1
  plt.figure(figsize=(15, 10))
  plt.subplot(1,2,1)
  plt.imshow(img)
  plt.title('Original image')
  plt.subplot(1,2,2)
  neg_img=a_max-img
  plt.imshow(neg_img)
  plt.title('Negative image')
img=plt.imread('q2.jpg')
#print(img)
f_invert(img)

